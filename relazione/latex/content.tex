\section{Obiettivo}
Il problema dello zaino multidimensionale (Multidimensional Knapsack Problem) è
un'estensione del più noto problema dello Zaino. L'obbiettivo è sempre lo
stesso, trovare un set di oggetti che massimizzi il profitto totale facendo in
modo di non superare la capienza massima dello zaino, solo con l'aggiunta di più
vincoli: non dovremmo solo preoccuparci della capienza dello zaino ma anche di
altri $n$ differenti fattori.\\

Questo problema può essere formalmente sintetizzato come segue:

\[
    \max \sum_{j=1}^{n} p_j x_j
\]

\[
    \text{subject to: } \sum_{j=1}^{n} r_{i,j} x_j \leq b_i, \ \ i = 1,2,\ldots, m
\]

con $x_j = \{0, 1\}$, $n$ il numero di oggetti, $m$ il numero di vincoli, $b$ il limite massimo per ogni vincolo,
$r$ il valore per ogni singolo vincolo di ogni oggetto.
Il problema verrà risolto mediante l'implementazione di un Algoritmo Genetico.

\section{Istanze del Problema}

L'algoritmo per la risoluzione di questo problema verrà testato utilizzando il dataset
\href{http://people.brunel.ac.uk/~mastjjb/jeb/orlib/mknapinfo.html}{OR-Library}: una
raccolta di varie istanze, di differenti dimensioni, per una svariata moltitudine di
problemi. Una singola istanza di presenta come segue:

\begin{lstlisting}[caption={Esempio di Istanza di un problema MKP con 6 oggetti e 10 vincoli.}]
6
100,600,1200,2400,500,2000
10
8,12,13,64,22,41
8,12,13,75,22,41
3,6,4,18,6,4
5,10,8,32,6,12
5,13,8,42,6,20
5,13,8,48,6,20
0,0,0,0,8,0
3,0,4,0,8,0
3,2,4,0,8,4
3,2,4,8,8,4
80,96,20,36,44,48,10,18,22,24
3800
\end{lstlisting}

La prima riga contiene il numero di oggetti, la seconda il valore di ogni singolo
oggetto, la terza il numero di parametri, le successive righe rappresentano i
valori dei coefficienti del primo parametro, del secondo e così via fin quando non si raggiunge il
numero di parametri. La penultima riga indica il valore massimo per ogni parametro (rappresenta quindi
il vincolo che non si può superare) e
l'ultima il valore della soluzione ottimale.

\begin{lstlisting}[caption={Rappresentazione sotto forma tabellare dell'istanza precedente}]
    ID  f0    f1    f2    f3    f4    f5   f6   f7   f8   f9   Value
    0   8.0   8.0   3.0   5.0   5.0   5.0  0.0  3.0  3.0  3.0   100.0
    1  12.0  12.0   6.0  10.0  13.0  13.0  0.0  0.0  2.0  2.0   600.0
    2  13.0  13.0   4.0   8.0   8.0   8.0  0.0  4.0  4.0  4.0  1200.0
    3  64.0  75.0  18.0  32.0  42.0  48.0  0.0  0.0  0.0  8.0  2400.0
    4  22.0  22.0   6.0   6.0   6.0   6.0  8.0  8.0  8.0  8.0   500.0
    5  41.0  41.0   4.0  12.0  20.0  20.0  0.0  0.0  4.0  4.0  2000.0
\end{lstlisting}

Prova di testo scritto e aggiornato di nuovo

\section{Implementazione}

Il problema descritto in precedenza verrà risolto mediante l'implementazione
di un Algoritmo Genetico. È stato scelto questo approccio per la sua
semplicità di implementazione e relativa velocità di esecuzione. Di seguito
saranno descritte le principali componenti che caratterizzano questo algoritmo.
% Vedremo come sarà necessario l'utilizzo di un operatore di 'riparazione' (repair operator)

\subsection{Initial Population}
La prima operazione per l'implementazione di un algoritmo genetico è quella di
andare a generare la popolazione iniziale. In questa implementazione verrà
fatto in maniera casuale applicando una strategia che permetterà di creare
elementi della popolazione (noti anche come \textit{cromosomi}) sempre ammissibili.
Questa operazione può essere descritta come segue:

\begin{enumerate}
    \item Crea una soluzione temporanea vuota (nessun oggetto),
    \item Estrai casualmente un oggetto tra quelli disponibili, \label{enum:loop}
    \item Prova ad aggiungere questo oggetto alla soluzione temporanea, \label{enum:check}
          \begin{itemize}
              \item se è possibile farlo: \begin{itemize}
                        \item aggiungi l'oggetto definitivamente alla soluzione,
                        \item rimuovi l'oggetto dagli oggetti disponibili,
                        \item continua dal punto \ref{enum:loop}.
                    \end{itemize}
              \item se non lo è: \begin{itemize}
                        \item aggiungi la soluzione creata alla lista delle
                              soluzioni generate fin ora.
                    \end{itemize}
          \end{itemize}
    \item Continua fin quando non è stato generato il numero desiderato di soluzioni.
\end{enumerate}

\begin{lstlisting}[caption={Pseudocodice per la Selezione della Popolazione iniziale.}]
PROCEDURE initialize_population
    INPUT:
        num_elem: number of solution to generate
        item_list: list of items
        num_items: number of items
        W: constraints upper bound

    population <- empty list of Solutions
    f_obj <- list of zeros with length num_elem

    FOR i <- 0 TO num_elem - 1 DO
        tmp_sol <- list of zeros with length num_items

        // list of item indexes
        T <- list of integers from 0 to num_items - 1

        R <- list of zeros with length equal to the
             number of constraints in the problem

        j <- randomly select an integer from T
        item <- item_list.pop(j)

        WHILE all elements of (R + item) <= W DO
            tmp_sol[j] <- 1
            R <- R + item

            IF length(T) <= 0 THEN
                EXIT WHILE loop
            END IF

            j <- randomly select an integer from T
            item <- item_list.pop(j)
        END WHILE

        APPEND tmp_sol to population
        f_obj[i] <- calculate the objective function value for tmp_sol
    END FOR
END PROCEDURE
\end{lstlisting}

Possiamo notare come nel punto \ref{enum:check}, grazie alle operazioni
descritte, ogni soluzione generata sarà sicuramente ammissibile perchè verrà
sempre controllato che, ogni qualvolta viene aggiunto un oggetto, la nuova
soluzione non superi i limiti massimi imposti al problema.

\subsection{Mating Pool Selection}
Una volta descritto come inizializzare la popolazione, và specificato come
selezionare gli individui per formare il Mating Pool, un insieme di $N/2$ coppie
che verranno utilizzate al passaggio successivo: \textbf{Crossover}. La
selezione del Mating Pool può avvenire in due modi: tramite \textit{Roulette
    Wheel} o \textit{Tournaments}. Per la semplicità di implementazione e
soprattutto per il basso costo computazionale è stato implementato il metodo
basato sui Tornei. Vengono selezionati casualmente un numero $k$ di elementi
della popolazione e tra questi viene preso il cromosoma con valore di fitness
più alto. Tramite questa operazione vengono generate $N/2$ coppie che poi verranno
passate all'operatore di Crossover.
Di seguito lo pseudocodice che riassume questa operazione.

\begin{lstlisting}[caption={Implementazione del metodo per la selezione del Mating Pool basata sui Tornei.}]
FUNCTION tournament(k: INTEGER) RETURNS Solution
    random_select_solutions = select k solution from population randomly

    max_index = select the index of solution with max fitness value
                in random_select_solutions

    RETURN population[max_index]
END FUNCTION

PROCEDURE select_mating_pool
    INPUT:
        population: List of all chromosomes (solutions)
        k: tournament parameter

    mating_pool = empty list

    FOR i <- 1 TO LENGTH(population) // 2 DO
        c1 = tournament(k)
        c2 = tournament(k)

        APPEND (c1, c2) to mating_pool
    END FOR

    RETURN mating_pool
END PROCEDURE
\end{lstlisting}

\subsection{Crossover Operator}
L'operatore di Crossover prende gli elementi del Mating Pool e genera un nuovo
elemento chiamato \textit{figlio}. Questo è un \textbf{Crossover Uniforme}: dati
due cromosomi, che prendono il nome di \textit{padri} (indicati con $s_1$ e
$s_2$), viene generato un nuovo individuo figlio che eredita in modo uniforme i
geni dai due padri. Il crossover viene eseguito con una probabilità data dal
parametro \verb|pcross|. Di seguito lo pseudocodice.

\begin{minipage}{\textwidth}
    \begin{lstlisting}
FUNCTION uniform_crossover_operator(s1, s2) RETURNS Solution
    c = ARRAY OF ZEROS with length LENGTH(s1)

    FOR i <- 1 TO LENGTH(s1) DO
        IF RANDOM_BOOLEAN() THEN
            c[i] = s1[i]
        ELSE
            c[i] = s2[i]
        END IF
    END FOR

    RETURN c
END FUNCTION

PROCEDURE do_crossover
    INPUT:
        mating_pool: N/2 couples from Selecting Mating Pool Phase
        pcross: Crossover probability

    children = empty list

    FOR EACH (s1, s2) IN mating_pool DO
        IF RANDOM_FLOAT() < pcross THEN
            c = uniform_crossover_operator(s1, s2)
            APPEND c to children
        ELSE
            APPEND s1 to children
            APPEND s2 to children
        END IF
    END FOR

    RETURN children
END PROCEDURE
\end{lstlisting}
    \captionof{lstlisting}{Implementazione dell'operatore di Crossover.}
\end{minipage}

\subsection{Mutation Operator}

L'operatore di Mutazione è il responsabile di alterare i geni dei cromosomi
risultanti dalla precedente fase di Crossover (indipendentemente se sono
genitori o figli). In base al parametro \verb|pmut| (\textit{mutation
    probability}), per ogni gene di ogni cromosoma, viene scelto se effettuare una
mutazione oppure no. La mutazione consiste nel cambiare il rispettivo gene
scelto tramite una semplice operazione di negazione.

\begin{minipage}{\textwidth}
    \begin{lstlisting}
PROCEDURE do_mutation
    INPUT:
        children: Crossover Phase Result
        pmut: Mutation Probability

    FOR EACH child in children do
        FOR i <- 0 TO LENGTH(child) - 1 DO
            IF RANDOM_FLOAT() < pmut THEN
                child[i] <- not child[i]
            END IF
        END FOR
    END FOR
END PROCEDURE
\end{lstlisting}
    \captionof{lstlisting}{Implementazione dell'operatore di Crossover.}
\end{minipage}

\subsection{Repair Operator}

Una volta terminata la fase di Mutazione, abbiamo in output una serie di
cromosomi figli che molto probabilmente non rispettano i criteri del problema e
non sono quindi soluzioni ammissibili. C'è la necessità quindi di andare a
\textquote*{riparare} ogni cromosoma che porti ad una soluzione non valida.
L'operatore che si occupa di questa procedura è stato implementato in 2 fai: la
prima \textbf{Sottrattiva} e la seconda \textbf{Additiva}. L'idea che c'è dietro
a questa procedura può essere riassunta come segue:

\begin{enumerate}
    \item Per ogni figlio controlla se è una soluzione ammissibile.
          \label{enum:looprep}
    \item Se lo è, torna al punto \ref{enum:looprep}
    \item Altrimenti:
          \begin{enumerate}
              \item \textbf{Fase Sottrattiva}: rimuovi un oggetto alla volta
                    dalla soluzione, fin quando la soluzione non diventa ammissibile
              \item \textbf{Fase Additiva}: aggiungi un oggetto alla volta alla
                    soluzione, fin quando è possibile (fin quando la soluzione
                    rimane ancora ammissibile).
              \item Torna al punto \ref{enum:looprep}
          \end{enumerate}
\end{enumerate}

Durante le due fasi, gli oggetti vengo scelti in modo ordinato in base ad un
parametro chiamato \textit{Importanza}. L'idea di base è di rimuovere prima gli
oggetti meno importanti e di aggiungere poi quelli più importanti. Questo parametro
viene calcolato in base alla seguente formula:

\begin{equation}
    Importance(j) = \frac{\sum_{i=1}^{m} r_{i,j} b_i}{\sum_{i=1}^{m} b_i} \frac{1}{p_j}
\end{equation}

\subsection{Select New Population}

\section{Stima dei Parametri}
\section{Valutazione delle Performance}

% \section{Nome del capitolo}
% \label{sec:capitolo}
% Aggiungi qui il contenuto della relazione !!\\
% \ \\
% Prova codice cmd
% \begin{lstlisting}[style=cmd]
%  this is a code in cmd style ...
% \end{lstlisting}
% \ \\
% Prova codice output
%
% \begin{lstlisting}[style=output]
%  this is a code in output style ...
% \end{lstlisting}
% \ \\
% Prova codice inline: \lstinline[style=cmd]|this is an inline code ...|\\
% \ \\
